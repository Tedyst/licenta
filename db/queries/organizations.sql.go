// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: organizations.sql

package queries

import (
	"context"
)

const addUserToOrganization = `-- name: AddUserToOrganization :exec
INSERT INTO organization_members(organization_id, user_id, ROLE)
    VALUES ($1, $2, $3)
`

type AddUserToOrganizationParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
	Role           int32 `json:"role"`
}

func (q *Queries) AddUserToOrganization(ctx context.Context, arg AddUserToOrganizationParams) error {
	_, err := q.db.Exec(ctx, addUserToOrganization, arg.OrganizationID, arg.UserID, arg.Role)
	return err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations(name)
    VALUES ($1)
RETURNING
    id, name, created_at
`

func (q *Queries) CreateOrganization(ctx context.Context, name string) (*Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return &i, err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrganization, id)
	return err
}

const getAllOrganizationProjectsForUser = `-- name: GetAllOrganizationProjectsForUser :many
SELECT
    id, name, organization_id, remote, created_at
FROM
    projects
WHERE
    organization_id IN (
        SELECT
            id
        FROM
            organizations
        WHERE
            id IN (
                SELECT
                    organization_id
                FROM
                    organization_members
                WHERE
                    user_id = $1))
`

func (q *Queries) GetAllOrganizationProjectsForUser(ctx context.Context, userID int64) ([]*Project, error) {
	rows, err := q.db.Query(ctx, getAllOrganizationProjectsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganizationID,
			&i.Remote,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :one
SELECT
    id, name, created_at
FROM
    organizations
WHERE
    id = $1
`

func (q *Queries) GetOrganization(ctx context.Context, id int64) (*Organization, error) {
	row := q.db.QueryRow(ctx, getOrganization, id)
	var i Organization
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return &i, err
}

const getOrganizationProjects = `-- name: GetOrganizationProjects :many
SELECT
    id, name, organization_id, remote, created_at
FROM
    projects
WHERE
    organization_id = $1
`

func (q *Queries) GetOrganizationProjects(ctx context.Context, organizationID int64) ([]*Project, error) {
	rows, err := q.db.Query(ctx, getOrganizationProjects, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganizationID,
			&i.Remote,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsForUser = `-- name: GetOrganizationsForUser :many
SELECT
    id, name, created_at
FROM
    organizations
WHERE
    id IN (
        SELECT
            organization_id
        FROM
            organization_members
        WHERE
            user_id = $1)
`

func (q *Queries) GetOrganizationsForUser(ctx context.Context, userID int64) ([]*Organization, error) {
	rows, err := q.db.Query(ctx, getOrganizationsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
