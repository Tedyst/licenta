// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: organizations.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToOrganization = `-- name: AddUserToOrganization :exec
INSERT INTO organization_members(organization_id, user_id, ROLE)
    VALUES ($1, $2, $3)
`

type AddUserToOrganizationParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
	Role           int32 `json:"role"`
}

func (q *Queries) AddUserToOrganization(ctx context.Context, arg AddUserToOrganizationParams) error {
	_, err := q.db.Exec(ctx, addUserToOrganization, arg.OrganizationID, arg.UserID, arg.Role)
	return err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations(name)
    VALUES ($1)
RETURNING
    id, name, created_at
`

func (q *Queries) CreateOrganization(ctx context.Context, name string) (*Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return &i, err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations
WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrganization, id)
	return err
}

const getAllOrganizationMembersForOrganizationsThatContainUser = `-- name: GetAllOrganizationMembersForOrganizationsThatContainUser :many
SELECT
    users.id, users.username, users.password, users.email, users.recovery_codes, users.totp_secret, users.recover_selector, users.recover_verifier, users.recover_expiry, users.login_attempt_count, users.login_last_attempt, users.locked, users.confirm_selector, users.confirm_verifier, users.confirmed, users.created_at,
    organization_members.id, organization_members.organization_id, organization_members.user_id, organization_members.role, organization_members.created_at
FROM
    organization_members
    INNER JOIN users ON organization_members.user_id = users.id
WHERE
    organization_id IN (
        SELECT
            id
        FROM
            organizations
        WHERE
            id IN (
                SELECT
                    organization_id
                FROM
                    organization_members
                WHERE
                    organization_members.user_id = $1))
`

type GetAllOrganizationMembersForOrganizationsThatContainUserRow struct {
	User               User               `json:"user"`
	OrganizationMember OrganizationMember `json:"organization_member"`
}

func (q *Queries) GetAllOrganizationMembersForOrganizationsThatContainUser(ctx context.Context, userID int64) ([]*GetAllOrganizationMembersForOrganizationsThatContainUserRow, error) {
	rows, err := q.db.Query(ctx, getAllOrganizationMembersForOrganizationsThatContainUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllOrganizationMembersForOrganizationsThatContainUserRow
	for rows.Next() {
		var i GetAllOrganizationMembersForOrganizationsThatContainUserRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Username,
			&i.User.Password,
			&i.User.Email,
			&i.User.RecoveryCodes,
			&i.User.TotpSecret,
			&i.User.RecoverSelector,
			&i.User.RecoverVerifier,
			&i.User.RecoverExpiry,
			&i.User.LoginAttemptCount,
			&i.User.LoginLastAttempt,
			&i.User.Locked,
			&i.User.ConfirmSelector,
			&i.User.ConfirmVerifier,
			&i.User.Confirmed,
			&i.User.CreatedAt,
			&i.OrganizationMember.ID,
			&i.OrganizationMember.OrganizationID,
			&i.OrganizationMember.UserID,
			&i.OrganizationMember.Role,
			&i.OrganizationMember.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOrganizationProjectsForUser = `-- name: GetAllOrganizationProjectsForUser :many
SELECT
    id, name, organization_id, remote, created_at
FROM
    projects
WHERE
    organization_id IN (
        SELECT
            id
        FROM
            organizations
        WHERE
            id IN (
                SELECT
                    organization_id
                FROM
                    organization_members
                WHERE
                    user_id = $1))
`

func (q *Queries) GetAllOrganizationProjectsForUser(ctx context.Context, userID int64) ([]*Project, error) {
	rows, err := q.db.Query(ctx, getAllOrganizationProjectsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganizationID,
			&i.Remote,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :one
SELECT
    id, name, created_at
FROM
    organizations
WHERE
    id = $1
`

func (q *Queries) GetOrganization(ctx context.Context, id int64) (*Organization, error) {
	row := q.db.QueryRow(ctx, getOrganization, id)
	var i Organization
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return &i, err
}

const getOrganizationProjects = `-- name: GetOrganizationProjects :many
SELECT
    id, name, organization_id, remote, created_at,
(
        SELECT
            COUNT(*)
        FROM
            scans
            INNER JOIN scan_groups ON scans.scan_group_id = scan_groups.id
        WHERE
            scan_groups.project_id = projects.id) AS scans
FROM
    projects
WHERE
    organization_id = $1
`

type GetOrganizationProjectsRow struct {
	ID             int64              `json:"id"`
	Name           string             `json:"name"`
	OrganizationID int64              `json:"organization_id"`
	Remote         bool               `json:"remote"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	Scans          int64              `json:"scans"`
}

func (q *Queries) GetOrganizationProjects(ctx context.Context, organizationID int64) ([]*GetOrganizationProjectsRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationProjects, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrganizationProjectsRow
	for rows.Next() {
		var i GetOrganizationProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OrganizationID,
			&i.Remote,
			&i.CreatedAt,
			&i.Scans,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationsForUser = `-- name: GetOrganizationsForUser :many
SELECT
    id, name, created_at
FROM
    organizations
WHERE
    id IN (
        SELECT
            organization_id
        FROM
            organization_members
        WHERE
            user_id = $1)
`

func (q *Queries) GetOrganizationsForUser(ctx context.Context, userID int64) ([]*Organization, error) {
	rows, err := q.db.Query(ctx, getOrganizationsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
