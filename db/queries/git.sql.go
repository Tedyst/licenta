// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: git.sql

package queries

import (
	"context"
	"database/sql"
)

const createGitCommitForProject = `-- name: CreateGitCommitForProject :one
INSERT INTO project_git_scanned_commits(project_id, commit_hash)
    VALUES ($1, $2)
RETURNING
    id, project_id, commit_hash, created_at
`

type CreateGitCommitForProjectParams struct {
	ProjectID  int64  `json:"project_id"`
	CommitHash string `json:"commit_hash"`
}

func (q *Queries) CreateGitCommitForProject(ctx context.Context, arg CreateGitCommitForProjectParams) (*ProjectGitScannedCommit, error) {
	row := q.db.QueryRow(ctx, createGitCommitForProject, arg.ProjectID, arg.CommitHash)
	var i ProjectGitScannedCommit
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CommitHash,
		&i.CreatedAt,
	)
	return &i, err
}

const createGitRepositoryForProject = `-- name: CreateGitRepositoryForProject :one
INSERT INTO project_git_repositories(project_id, git_repository, username, PASSWORD)
    VALUES ($1, $2, $3, $4)
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type CreateGitRepositoryForProjectParams struct {
	ProjectID     int64          `json:"project_id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
}

func (q *Queries) CreateGitRepositoryForProject(ctx context.Context, arg CreateGitRepositoryForProjectParams) (*ProjectGitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepositoryForProject,
		arg.ProjectID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
	)
	var i ProjectGitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

type CreateGitResultForCommitParams struct {
	ProjectID   int64          `json:"project_id"`
	Commit      int64          `json:"commit"`
	Name        string         `json:"name"`
	Line        string         `json:"line"`
	LineNumber  int32          `json:"line_number"`
	Match       string         `json:"match"`
	Probability float64        `json:"probability"`
	Username    sql.NullString `json:"username"`
	Password    sql.NullString `json:"password"`
	Filename    string         `json:"filename"`
}

const deleteGitRepositoryForProject = `-- name: DeleteGitRepositoryForProject :exec
DELETE FROM project_git_repositories
WHERE project_id = $1
    AND git_repository = $2
`

type DeleteGitRepositoryForProjectParams struct {
	ProjectID     int64  `json:"project_id"`
	GitRepository string `json:"git_repository"`
}

func (q *Queries) DeleteGitRepositoryForProject(ctx context.Context, arg DeleteGitRepositoryForProjectParams) error {
	_, err := q.db.Exec(ctx, deleteGitRepositoryForProject, arg.ProjectID, arg.GitRepository)
	return err
}

const getGitRepositoriesForProject = `-- name: GetGitRepositoriesForProject :many
SELECT
    id, project_id, git_repository, username, password, private_key, created_at
FROM
    project_git_repositories
WHERE
    project_id = $1
`

func (q *Queries) GetGitRepositoriesForProject(ctx context.Context, projectID int64) ([]*ProjectGitRepository, error) {
	rows, err := q.db.Query(ctx, getGitRepositoriesForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProjectGitRepository
	for rows.Next() {
		var i ProjectGitRepository
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.GitRepository,
			&i.Username,
			&i.Password,
			&i.PrivateKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepository = `-- name: GetGitRepository :one
SELECT
    id, project_id, git_repository, username, password, private_key, created_at
FROM
    project_git_repositories
WHERE
    id = $1
`

func (q *Queries) GetGitRepository(ctx context.Context, id int64) (*ProjectGitRepository, error) {
	row := q.db.QueryRow(ctx, getGitRepository, id)
	var i ProjectGitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const getGitScannedCommitsForProject = `-- name: GetGitScannedCommitsForProject :many
SELECT
    commit_hash
FROM
    project_git_scanned_commits
WHERE
    project_id = $1
`

func (q *Queries) GetGitScannedCommitsForProject(ctx context.Context, projectID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitScannedCommitsForProjectBatch = `-- name: GetGitScannedCommitsForProjectBatch :many
SELECT
    commit_hash
FROM
    project_git_scanned_commits
WHERE
    project_id = $1
    AND commit_hash = ANY ($2::string[])
`

type GetGitScannedCommitsForProjectBatchParams struct {
	ProjectID    int64    `json:"project_id"`
	CommitHashes []string `json:"commit_hashes"`
}

func (q *Queries) GetGitScannedCommitsForProjectBatch(ctx context.Context, arg GetGitScannedCommitsForProjectBatchParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProjectBatch, arg.ProjectID, arg.CommitHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
