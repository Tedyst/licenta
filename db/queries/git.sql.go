// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: git.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGitCommitForProject = `-- name: CreateGitCommitForProject :one
INSERT INTO git_commits(repository_id, commit_hash, author, author_email, description, commit_date)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, repository_id, commit_hash, author, author_email, commit_date, description, created_at
`

type CreateGitCommitForProjectParams struct {
	RepositoryID int64              `json:"repository_id"`
	CommitHash   string             `json:"commit_hash"`
	Author       sql.NullString     `json:"author"`
	AuthorEmail  sql.NullString     `json:"author_email"`
	Description  sql.NullString     `json:"description"`
	CommitDate   pgtype.Timestamptz `json:"commit_date"`
}

func (q *Queries) CreateGitCommitForProject(ctx context.Context, arg CreateGitCommitForProjectParams) (*GitCommit, error) {
	row := q.db.QueryRow(ctx, createGitCommitForProject,
		arg.RepositoryID,
		arg.CommitHash,
		arg.Author,
		arg.AuthorEmail,
		arg.Description,
		arg.CommitDate,
	)
	var i GitCommit
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.CommitHash,
		&i.Author,
		&i.AuthorEmail,
		&i.CommitDate,
		&i.Description,
		&i.CreatedAt,
	)
	return &i, err
}

const createGitRepository = `-- name: CreateGitRepository :one
INSERT INTO git_repositories(project_id, git_repository, username, PASSWORD, private_key)
    VALUES ($1, $2, $3, $4, $5)
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type CreateGitRepositoryParams struct {
	ProjectID     int64          `json:"project_id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
	PrivateKey    sql.NullString `json:"private_key"`
}

func (q *Queries) CreateGitRepository(ctx context.Context, arg CreateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepository,
		arg.ProjectID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
		arg.PrivateKey,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const createGitRepositoryForProject = `-- name: CreateGitRepositoryForProject :one
INSERT INTO git_repositories(project_id, git_repository, username, PASSWORD)
    VALUES ($1, $2, $3, $4)
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type CreateGitRepositoryForProjectParams struct {
	ProjectID     int64          `json:"project_id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
}

func (q *Queries) CreateGitRepositoryForProject(ctx context.Context, arg CreateGitRepositoryForProjectParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepositoryForProject,
		arg.ProjectID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

type CreateGitResultForCommitParams struct {
	Commit      int64          `json:"commit"`
	Name        string         `json:"name"`
	Line        string         `json:"line"`
	LineNumber  int32          `json:"line_number"`
	Match       string         `json:"match"`
	Probability float64        `json:"probability"`
	Username    sql.NullString `json:"username"`
	Password    sql.NullString `json:"password"`
	Filename    string         `json:"filename"`
}

const deleteGitRepository = `-- name: DeleteGitRepository :exec
DELETE FROM git_repositories
WHERE id = $1
`

func (q *Queries) DeleteGitRepository(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGitRepository, id)
	return err
}

const deleteGitRepositoryForProject = `-- name: DeleteGitRepositoryForProject :exec
DELETE FROM git_repositories
WHERE project_id = $1
    AND git_repository = $2
`

type DeleteGitRepositoryForProjectParams struct {
	ProjectID     int64  `json:"project_id"`
	GitRepository string `json:"git_repository"`
}

func (q *Queries) DeleteGitRepositoryForProject(ctx context.Context, arg DeleteGitRepositoryForProjectParams) error {
	_, err := q.db.Exec(ctx, deleteGitRepositoryForProject, arg.ProjectID, arg.GitRepository)
	return err
}

const getGitCommitsWithResults = `-- name: GetGitCommitsWithResults :many
SELECT
    commit_id, repository_id, commit_hash, author, author_email, commit_date, description, commit_created_at, id, commit, name, line, line_number, match, probability, username, password, filename, created_at
FROM ((
        SELECT
            git_commits.id AS commit_id,
            git_commits.repository_id,
            git_commits.commit_hash,
            git_commits.author,
            git_commits.author_email,
            git_commits.commit_date,
            git_commits.description,
            git_commits.created_at AS commit_created_at,
            git_results.id, git_results.commit, git_results.name, git_results.line, git_results.line_number, git_results.match, git_results.probability, git_results.username, git_results.password, git_results.filename, git_results.created_at
        FROM
            git_commits
        LEFT JOIN git_results ON git_commits.id = git_results.commit
    WHERE
        git_commits.repository_id = $1
        AND git_results.id IS NULL
    ORDER BY
        git_commits.commit_date DESC
    LIMIT 25)
UNION (
    SELECT
        git_commits.id AS commit_id,
        git_commits.repository_id,
        git_commits.commit_hash,
        git_commits.author,
        git_commits.author_email,
        git_commits.commit_date,
        git_commits.description,
        git_commits.created_at AS commit_created_at,
        git_results.id, git_results.commit, git_results.name, git_results.line, git_results.line_number, git_results.match, git_results.probability, git_results.username, git_results.password, git_results.filename, git_results.created_at
    FROM
        git_commits
    LEFT JOIN git_results ON git_commits.id = git_results.commit
WHERE
    git_commits.repository_id = $1
    AND git_results.id IS NOT NULL)) AS asd
ORDER BY
    commit_date DESC
`

type GetGitCommitsWithResultsRow struct {
	CommitID        int64              `json:"commit_id"`
	RepositoryID    int64              `json:"repository_id"`
	CommitHash      string             `json:"commit_hash"`
	Author          sql.NullString     `json:"author"`
	AuthorEmail     sql.NullString     `json:"author_email"`
	CommitDate      pgtype.Timestamptz `json:"commit_date"`
	Description     sql.NullString     `json:"description"`
	CommitCreatedAt pgtype.Timestamptz `json:"commit_created_at"`
	ID              pgtype.Int8        `json:"id"`
	Commit          sql.NullInt64      `json:"commit"`
	Name            sql.NullString     `json:"name"`
	Line            sql.NullString     `json:"line"`
	LineNumber      sql.NullInt32      `json:"line_number"`
	Match           sql.NullString     `json:"match"`
	Probability     sql.NullFloat64    `json:"probability"`
	Username        sql.NullString     `json:"username"`
	Password        sql.NullString     `json:"password"`
	Filename        sql.NullString     `json:"filename"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetGitCommitsWithResults(ctx context.Context, repositoryID int64) ([]*GetGitCommitsWithResultsRow, error) {
	rows, err := q.db.Query(ctx, getGitCommitsWithResults, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGitCommitsWithResultsRow
	for rows.Next() {
		var i GetGitCommitsWithResultsRow
		if err := rows.Scan(
			&i.CommitID,
			&i.RepositoryID,
			&i.CommitHash,
			&i.Author,
			&i.AuthorEmail,
			&i.CommitDate,
			&i.Description,
			&i.CommitCreatedAt,
			&i.ID,
			&i.Commit,
			&i.Name,
			&i.Line,
			&i.LineNumber,
			&i.Match,
			&i.Probability,
			&i.Username,
			&i.Password,
			&i.Filename,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepositoriesForProject = `-- name: GetGitRepositoriesForProject :many
SELECT
    id, project_id, git_repository, username, password, private_key, created_at
FROM
    git_repositories
WHERE
    project_id = $1
`

func (q *Queries) GetGitRepositoriesForProject(ctx context.Context, projectID int64) ([]*GitRepository, error) {
	rows, err := q.db.Query(ctx, getGitRepositoriesForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GitRepository
	for rows.Next() {
		var i GitRepository
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.GitRepository,
			&i.Username,
			&i.Password,
			&i.PrivateKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepository = `-- name: GetGitRepository :one
SELECT
    id, project_id, git_repository, username, password, private_key, created_at
FROM
    git_repositories
WHERE
    id = $1
`

func (q *Queries) GetGitRepository(ctx context.Context, id int64) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, getGitRepository, id)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const getGitScannedCommitsForProject = `-- name: GetGitScannedCommitsForProject :many
SELECT
    commit_hash
FROM
    git_commits
    INNER JOIN git_repositories ON git_repositories.id = git_commits.repository_id
WHERE
    git_repositories.project_id = $1
`

func (q *Queries) GetGitScannedCommitsForProject(ctx context.Context, projectID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitScannedCommitsForProjectBatch = `-- name: GetGitScannedCommitsForProjectBatch :many
SELECT
    commit_hash
FROM
    git_commits
    INNER JOIN git_repositories ON git_repositories.id = git_commits.repository_id
WHERE
    project_id = $1
    AND commit_hash = ANY ($2::text[])
`

type GetGitScannedCommitsForProjectBatchParams struct {
	ProjectID    int64    `json:"project_id"`
	CommitHashes []string `json:"commit_hashes"`
}

func (q *Queries) GetGitScannedCommitsForProjectBatch(ctx context.Context, arg GetGitScannedCommitsForProjectBatchParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProjectBatch, arg.ProjectID, arg.CommitHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGitRepository = `-- name: UpdateGitRepository :one
UPDATE
    git_repositories
SET
    git_repository = $2,
    username = $3,
    PASSWORD = $4,
    private_key = $5
WHERE
    id = $1
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type UpdateGitRepositoryParams struct {
	ID            int64          `json:"id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
	PrivateKey    sql.NullString `json:"private_key"`
}

func (q *Queries) UpdateGitRepository(ctx context.Context, arg UpdateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, updateGitRepository,
		arg.ID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
		arg.PrivateKey,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}
