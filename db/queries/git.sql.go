// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: git.sql

package queries

import (
	"context"
	"database/sql"
)

const createGitCommitForProject = `-- name: CreateGitCommitForProject :one
INSERT INTO git_commits(repository_id, commit_hash)
    VALUES ($1, $2)
RETURNING
    id, repository_id, commit_hash, created_at
`

type CreateGitCommitForProjectParams struct {
	RepositoryID int64  `json:"repository_id"`
	CommitHash   string `json:"commit_hash"`
}

func (q *Queries) CreateGitCommitForProject(ctx context.Context, arg CreateGitCommitForProjectParams) (*GitCommit, error) {
	row := q.db.QueryRow(ctx, createGitCommitForProject, arg.RepositoryID, arg.CommitHash)
	var i GitCommit
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.CommitHash,
		&i.CreatedAt,
	)
	return &i, err
}

const createGitRepository = `-- name: CreateGitRepository :one
INSERT INTO git_repositories(project_id, git_repository, username, PASSWORD, private_key)
    VALUES ($1, $2, $3, $4, $5)
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type CreateGitRepositoryParams struct {
	ProjectID     int64          `json:"project_id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
	PrivateKey    sql.NullString `json:"private_key"`
}

func (q *Queries) CreateGitRepository(ctx context.Context, arg CreateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepository,
		arg.ProjectID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
		arg.PrivateKey,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const createGitRepositoryForProject = `-- name: CreateGitRepositoryForProject :one
INSERT INTO git_repositories(project_id, git_repository, username, PASSWORD)
    VALUES ($1, $2, $3, $4)
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type CreateGitRepositoryForProjectParams struct {
	ProjectID     int64          `json:"project_id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
}

func (q *Queries) CreateGitRepositoryForProject(ctx context.Context, arg CreateGitRepositoryForProjectParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepositoryForProject,
		arg.ProjectID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

type CreateGitResultForCommitParams struct {
	Commit      int64          `json:"commit"`
	Name        string         `json:"name"`
	Line        string         `json:"line"`
	LineNumber  int32          `json:"line_number"`
	Match       string         `json:"match"`
	Probability float64        `json:"probability"`
	Username    sql.NullString `json:"username"`
	Password    sql.NullString `json:"password"`
	Filename    string         `json:"filename"`
}

const deleteGitRepository = `-- name: DeleteGitRepository :exec
DELETE FROM git_repositories
WHERE id = $1
`

func (q *Queries) DeleteGitRepository(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGitRepository, id)
	return err
}

const deleteGitRepositoryForProject = `-- name: DeleteGitRepositoryForProject :exec
DELETE FROM git_repositories
WHERE project_id = $1
    AND git_repository = $2
`

type DeleteGitRepositoryForProjectParams struct {
	ProjectID     int64  `json:"project_id"`
	GitRepository string `json:"git_repository"`
}

func (q *Queries) DeleteGitRepositoryForProject(ctx context.Context, arg DeleteGitRepositoryForProjectParams) error {
	_, err := q.db.Exec(ctx, deleteGitRepositoryForProject, arg.ProjectID, arg.GitRepository)
	return err
}

const getGitCommitsWithResults = `-- name: GetGitCommitsWithResults :many
SELECT
    git_commits.id, git_commits.repository_id, git_commits.commit_hash, git_commits.created_at,
    git_results.id, git_results.commit, git_results.name, git_results.line, git_results.line_number, git_results.match, git_results.probability, git_results.username, git_results.password, git_results.filename, git_results.created_at
FROM
    git_commits
    LEFT JOIN git_results ON git_commits.commit_hash = git_results.commit
WHERE
    git_commits.repository_id = $1
`

type GetGitCommitsWithResultsRow struct {
	GitCommit GitCommit `json:"git_commit"`
	GitResult GitResult `json:"git_result"`
}

func (q *Queries) GetGitCommitsWithResults(ctx context.Context, repositoryID int64) ([]*GetGitCommitsWithResultsRow, error) {
	rows, err := q.db.Query(ctx, getGitCommitsWithResults, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGitCommitsWithResultsRow
	for rows.Next() {
		var i GetGitCommitsWithResultsRow
		if err := rows.Scan(
			&i.GitCommit.ID,
			&i.GitCommit.RepositoryID,
			&i.GitCommit.CommitHash,
			&i.GitCommit.CreatedAt,
			&i.GitResult.ID,
			&i.GitResult.Commit,
			&i.GitResult.Name,
			&i.GitResult.Line,
			&i.GitResult.LineNumber,
			&i.GitResult.Match,
			&i.GitResult.Probability,
			&i.GitResult.Username,
			&i.GitResult.Password,
			&i.GitResult.Filename,
			&i.GitResult.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepositoriesForProject = `-- name: GetGitRepositoriesForProject :many
SELECT
    id, project_id, git_repository, username, password, private_key, created_at
FROM
    git_repositories
WHERE
    project_id = $1
`

func (q *Queries) GetGitRepositoriesForProject(ctx context.Context, projectID int64) ([]*GitRepository, error) {
	rows, err := q.db.Query(ctx, getGitRepositoriesForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GitRepository
	for rows.Next() {
		var i GitRepository
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.GitRepository,
			&i.Username,
			&i.Password,
			&i.PrivateKey,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepository = `-- name: GetGitRepository :one
SELECT
    id, project_id, git_repository, username, password, private_key, created_at
FROM
    git_repositories
WHERE
    id = $1
`

func (q *Queries) GetGitRepository(ctx context.Context, id int64) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, getGitRepository, id)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

const getGitScannedCommitsForProject = `-- name: GetGitScannedCommitsForProject :many
SELECT
    commit_hash
FROM
    git_commits
    INNER JOIN git_repositories ON git_repositories.id = git_commits.repository_id
WHERE
    git_repositories.project_id = $1
`

func (q *Queries) GetGitScannedCommitsForProject(ctx context.Context, projectID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitScannedCommitsForProjectBatch = `-- name: GetGitScannedCommitsForProjectBatch :many
SELECT
    commit_hash
FROM
    git_commits
    INNER JOIN git_repositories ON git_repositories.id = git_commits.repository_id
WHERE
    project_id = $1
    AND commit_hash = ANY ($2::string[])
`

type GetGitScannedCommitsForProjectBatchParams struct {
	ProjectID    int64    `json:"project_id"`
	CommitHashes []string `json:"commit_hashes"`
}

func (q *Queries) GetGitScannedCommitsForProjectBatch(ctx context.Context, arg GetGitScannedCommitsForProjectBatchParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProjectBatch, arg.ProjectID, arg.CommitHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGitRepository = `-- name: UpdateGitRepository :one
UPDATE
    git_repositories
SET
    git_repository = $2,
    username = $3,
    PASSWORD = $4,
    private_key = $5
WHERE
    id = $1
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type UpdateGitRepositoryParams struct {
	ID            int64          `json:"id"`
	GitRepository string         `json:"git_repository"`
	Username      sql.NullString `json:"username"`
	Password      sql.NullString `json:"password"`
	PrivateKey    sql.NullString `json:"private_key"`
}

func (q *Queries) UpdateGitRepository(ctx context.Context, arg UpdateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, updateGitRepository,
		arg.ID,
		arg.GitRepository,
		arg.Username,
		arg.Password,
		arg.PrivateKey,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}
