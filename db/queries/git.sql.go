// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: git.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGitCommitForProject = `-- name: CreateGitCommitForProject :one
INSERT INTO git_commits(repository_id, commit_hash, author, author_email, description, commit_date)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, repository_id, commit_hash, author, author_email, commit_date, description, created_at
`

type CreateGitCommitForProjectParams struct {
	RepositoryID int64              `json:"repository_id"`
	CommitHash   string             `json:"commit_hash"`
	Author       sql.NullString     `json:"author"`
	AuthorEmail  sql.NullString     `json:"author_email"`
	Description  sql.NullString     `json:"description"`
	CommitDate   pgtype.Timestamptz `json:"commit_date"`
}

func (q *Queries) CreateGitCommitForProject(ctx context.Context, arg CreateGitCommitForProjectParams) (*GitCommit, error) {
	row := q.db.QueryRow(ctx, createGitCommitForProject,
		arg.RepositoryID,
		arg.CommitHash,
		arg.Author,
		arg.AuthorEmail,
		arg.Description,
		arg.CommitDate,
	)
	var i GitCommit
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.CommitHash,
		&i.Author,
		&i.AuthorEmail,
		&i.CommitDate,
		&i.Description,
		&i.CreatedAt,
	)
	return &i, err
}

const createGitRepository = `-- name: CreateGitRepository :one
INSERT INTO git_repositories(project_id, git_repository, username, PASSWORD, private_key)
    VALUES ($1, $2, encrypt_data($1, $3, $4), encrypt_data($1, $3, $5), encrypt_data($1, $3, $6))
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type CreateGitRepositoryParams struct {
	ProjectID     int64  `json:"project_id"`
	GitRepository string `json:"git_repository"`
	SaltKey       string `json:"salt_key"`
	Username      string `json:"username"`
	Password      string `json:"password"`
	PrivateKey    string `json:"private_key"`
}

func (q *Queries) CreateGitRepository(ctx context.Context, arg CreateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepository,
		arg.ProjectID,
		arg.GitRepository,
		arg.SaltKey,
		arg.Username,
		arg.Password,
		arg.PrivateKey,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}

type CreateGitResultForCommitParams struct {
	Commit      int64          `json:"commit"`
	Name        string         `json:"name"`
	Line        string         `json:"line"`
	LineNumber  int32          `json:"line_number"`
	Match       string         `json:"match"`
	Probability float64        `json:"probability"`
	Username    sql.NullString `json:"username"`
	Password    sql.NullString `json:"password"`
	Filename    string         `json:"filename"`
}

const createGitScan = `-- name: CreateGitScan :one
INSERT INTO git_scans(repository_id, scan_id)
    VALUES ($1, $2)
RETURNING
    id, scan_id, repository_id
`

type CreateGitScanParams struct {
	RepositoryID int64 `json:"repository_id"`
	ScanID       int64 `json:"scan_id"`
}

func (q *Queries) CreateGitScan(ctx context.Context, arg CreateGitScanParams) (*GitScan, error) {
	row := q.db.QueryRow(ctx, createGitScan, arg.RepositoryID, arg.ScanID)
	var i GitScan
	err := row.Scan(&i.ID, &i.ScanID, &i.RepositoryID)
	return &i, err
}

const deleteGitRepository = `-- name: DeleteGitRepository :exec
DELETE FROM git_repositories
WHERE id = $1
`

func (q *Queries) DeleteGitRepository(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGitRepository, id)
	return err
}

const getGitCommitsWithResults = `-- name: GetGitCommitsWithResults :many
SELECT
    commit_id, repository_id, commit_hash, author, author_email, commit_date, description, commit_created_at, id, commit, name, line, line_number, match, probability, username, password, filename, created_at
FROM ((
        SELECT
            git_commits.id AS commit_id,
            git_commits.repository_id,
            git_commits.commit_hash,
            git_commits.author,
            git_commits.author_email,
            git_commits.commit_date,
            git_commits.description,
            git_commits.created_at AS commit_created_at,
            git_results.id, git_results.commit, git_results.name, git_results.line, git_results.line_number, git_results.match, git_results.probability, git_results.username, git_results.password, git_results.filename, git_results.created_at
        FROM
            git_commits
        LEFT JOIN git_results ON git_commits.id = git_results.commit
    WHERE
        git_commits.repository_id = $1
        AND git_results.id IS NULL
    ORDER BY
        git_commits.commit_date DESC
    LIMIT 25)
UNION (
    SELECT
        git_commits.id AS commit_id,
        git_commits.repository_id,
        git_commits.commit_hash,
        git_commits.author,
        git_commits.author_email,
        git_commits.commit_date,
        git_commits.description,
        git_commits.created_at AS commit_created_at,
        git_results.id, git_results.commit, git_results.name, git_results.line, git_results.line_number, git_results.match, git_results.probability, git_results.username, git_results.password, git_results.filename, git_results.created_at
    FROM
        git_commits
    LEFT JOIN git_results ON git_commits.id = git_results.commit
WHERE
    git_commits.repository_id = $1
    AND git_results.id IS NOT NULL)) AS asd
ORDER BY
    commit_date DESC
`

type GetGitCommitsWithResultsRow struct {
	CommitID        int64              `json:"commit_id"`
	RepositoryID    int64              `json:"repository_id"`
	CommitHash      string             `json:"commit_hash"`
	Author          sql.NullString     `json:"author"`
	AuthorEmail     sql.NullString     `json:"author_email"`
	CommitDate      pgtype.Timestamptz `json:"commit_date"`
	Description     sql.NullString     `json:"description"`
	CommitCreatedAt pgtype.Timestamptz `json:"commit_created_at"`
	ID              pgtype.Int8        `json:"id"`
	Commit          sql.NullInt64      `json:"commit"`
	Name            sql.NullString     `json:"name"`
	Line            sql.NullString     `json:"line"`
	LineNumber      sql.NullInt32      `json:"line_number"`
	Match           sql.NullString     `json:"match"`
	Probability     sql.NullFloat64    `json:"probability"`
	Username        sql.NullString     `json:"username"`
	Password        sql.NullString     `json:"password"`
	Filename        sql.NullString     `json:"filename"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetGitCommitsWithResults(ctx context.Context, repositoryID int64) ([]*GetGitCommitsWithResultsRow, error) {
	rows, err := q.db.Query(ctx, getGitCommitsWithResults, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGitCommitsWithResultsRow
	for rows.Next() {
		var i GetGitCommitsWithResultsRow
		if err := rows.Scan(
			&i.CommitID,
			&i.RepositoryID,
			&i.CommitHash,
			&i.Author,
			&i.AuthorEmail,
			&i.CommitDate,
			&i.Description,
			&i.CommitCreatedAt,
			&i.ID,
			&i.Commit,
			&i.Name,
			&i.Line,
			&i.LineNumber,
			&i.Match,
			&i.Probability,
			&i.Username,
			&i.Password,
			&i.Filename,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepositoriesForProject = `-- name: GetGitRepositoriesForProject :many
SELECT
    id,
    project_id,
    git_repository,
    decrypt_data(project_id, $2, username) AS username,
    decrypt_data(project_id, $2, PASSWORD) AS PASSWORD,
    decrypt_data(project_id, $2, private_key) AS private_key
FROM
    git_repositories
WHERE
    project_id = $1
`

type GetGitRepositoriesForProjectParams struct {
	ProjectID int64  `json:"project_id"`
	SaltKey   string `json:"salt_key"`
}

type GetGitRepositoriesForProjectRow struct {
	ID            int64  `json:"id"`
	ProjectID     int64  `json:"project_id"`
	GitRepository string `json:"git_repository"`
	Username      string `json:"username"`
	Password      string `json:"password"`
	PrivateKey    string `json:"private_key"`
}

func (q *Queries) GetGitRepositoriesForProject(ctx context.Context, arg GetGitRepositoriesForProjectParams) ([]*GetGitRepositoriesForProjectRow, error) {
	rows, err := q.db.Query(ctx, getGitRepositoriesForProject, arg.ProjectID, arg.SaltKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGitRepositoriesForProjectRow
	for rows.Next() {
		var i GetGitRepositoriesForProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.GitRepository,
			&i.Username,
			&i.Password,
			&i.PrivateKey,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitRepository = `-- name: GetGitRepository :one
SELECT
    id,
    project_id,
    git_repository,
    decrypt_data(project_id, $2, username) AS username,
    decrypt_data(project_id, $2, PASSWORD) AS PASSWORD,
    decrypt_data(project_id, $2, private_key) AS private_key
FROM
    git_repositories
WHERE
    id = $1
`

type GetGitRepositoryParams struct {
	ID      int64  `json:"id"`
	SaltKey string `json:"salt_key"`
}

type GetGitRepositoryRow struct {
	ID            int64  `json:"id"`
	ProjectID     int64  `json:"project_id"`
	GitRepository string `json:"git_repository"`
	Username      string `json:"username"`
	Password      string `json:"password"`
	PrivateKey    string `json:"private_key"`
}

func (q *Queries) GetGitRepository(ctx context.Context, arg GetGitRepositoryParams) (*GetGitRepositoryRow, error) {
	row := q.db.QueryRow(ctx, getGitRepository, arg.ID, arg.SaltKey)
	var i GetGitRepositoryRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
	)
	return &i, err
}

const getGitScanByScan = `-- name: GetGitScanByScan :many
SELECT
    id, scan_id, repository_id
FROM
    git_scans
WHERE
    scan_id = $1
`

func (q *Queries) GetGitScanByScan(ctx context.Context, scanID int64) ([]*GitScan, error) {
	rows, err := q.db.Query(ctx, getGitScanByScan, scanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GitScan
	for rows.Next() {
		var i GitScan
		if err := rows.Scan(&i.ID, &i.ScanID, &i.RepositoryID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitScanByScanAndRepo = `-- name: GetGitScanByScanAndRepo :one
SELECT
    git_scans.id, git_scans.scan_id, git_scans.repository_id,
    scans.id, scans.scan_group_id, scans.scan_type, scans.status, scans.error, scans.worker_id, scans.created_at, scans.ended_at
FROM
    git_scans
    INNER JOIN scans ON scans.id = git_scans.scan_id
WHERE
    scans.scan_group_id = $1
    AND repository_id = $2
`

type GetGitScanByScanAndRepoParams struct {
	ScanGroupID  int64 `json:"scan_group_id"`
	RepositoryID int64 `json:"repository_id"`
}

type GetGitScanByScanAndRepoRow struct {
	GitScan GitScan `json:"git_scan"`
	Scan    Scan    `json:"scan"`
}

func (q *Queries) GetGitScanByScanAndRepo(ctx context.Context, arg GetGitScanByScanAndRepoParams) (*GetGitScanByScanAndRepoRow, error) {
	row := q.db.QueryRow(ctx, getGitScanByScanAndRepo, arg.ScanGroupID, arg.RepositoryID)
	var i GetGitScanByScanAndRepoRow
	err := row.Scan(
		&i.GitScan.ID,
		&i.GitScan.ScanID,
		&i.GitScan.RepositoryID,
		&i.Scan.ID,
		&i.Scan.ScanGroupID,
		&i.Scan.ScanType,
		&i.Scan.Status,
		&i.Scan.Error,
		&i.Scan.WorkerID,
		&i.Scan.CreatedAt,
		&i.Scan.EndedAt,
	)
	return &i, err
}

const getGitScannedCommitsForProject = `-- name: GetGitScannedCommitsForProject :many
SELECT
    commit_hash
FROM
    git_commits
    INNER JOIN git_repositories ON git_repositories.id = git_commits.repository_id
WHERE
    git_repositories.project_id = $1
`

func (q *Queries) GetGitScannedCommitsForProject(ctx context.Context, projectID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGitScannedCommitsForProjectBatch = `-- name: GetGitScannedCommitsForProjectBatch :many
SELECT
    commit_hash
FROM
    git_commits
    INNER JOIN git_repositories ON git_repositories.id = git_commits.repository_id
WHERE
    project_id = $1
    AND commit_hash = ANY ($2::text[])
`

type GetGitScannedCommitsForProjectBatchParams struct {
	ProjectID    int64    `json:"project_id"`
	CommitHashes []string `json:"commit_hashes"`
}

func (q *Queries) GetGitScannedCommitsForProjectBatch(ctx context.Context, arg GetGitScannedCommitsForProjectBatchParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getGitScannedCommitsForProjectBatch, arg.ProjectID, arg.CommitHashes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var commit_hash string
		if err := rows.Scan(&commit_hash); err != nil {
			return nil, err
		}
		items = append(items, commit_hash)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGitRepository = `-- name: UpdateGitRepository :one
UPDATE
    git_repositories
SET
    git_repository = $2,
    username = encrypt_data($3, $4, $5),
    PASSWORD = encrypt_data($3, $4, $6),
    private_key = encrypt_data($3, $4, $7)
WHERE
    id = $1
RETURNING
    id, project_id, git_repository, username, password, private_key, created_at
`

type UpdateGitRepositoryParams struct {
	ID            int64  `json:"id"`
	GitRepository string `json:"git_repository"`
	ProjectID     int64  `json:"project_id"`
	SaltKey       string `json:"salt_key"`
	Username      string `json:"username"`
	Password      string `json:"password"`
	PrivateKey    string `json:"private_key"`
}

func (q *Queries) UpdateGitRepository(ctx context.Context, arg UpdateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, updateGitRepository,
		arg.ID,
		arg.GitRepository,
		arg.ProjectID,
		arg.SaltKey,
		arg.Username,
		arg.Password,
		arg.PrivateKey,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.GitRepository,
		&i.Username,
		&i.Password,
		&i.PrivateKey,
		&i.CreatedAt,
	)
	return &i, err
}
