// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: mysql.sql

package queries

import (
	"context"
	"database/sql"
)

const createMysqlDatabase = `-- name: CreateMysqlDatabase :one
INSERT INTO mysql_databases(project_id, database_name, host, port, username, PASSWORD, version)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING
    id, project_id, host, port, database_name, username, password, version, created_at
`

type CreateMysqlDatabaseParams struct {
	ProjectID    int64          `json:"project_id"`
	DatabaseName string         `json:"database_name"`
	Host         string         `json:"host"`
	Port         int32          `json:"port"`
	Username     string         `json:"username"`
	Password     string         `json:"password"`
	Version      sql.NullString `json:"version"`
}

func (q *Queries) CreateMysqlDatabase(ctx context.Context, arg CreateMysqlDatabaseParams) (*MysqlDatabase, error) {
	row := q.db.QueryRow(ctx, createMysqlDatabase,
		arg.ProjectID,
		arg.DatabaseName,
		arg.Host,
		arg.Port,
		arg.Username,
		arg.Password,
		arg.Version,
	)
	var i MysqlDatabase
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Host,
		&i.Port,
		&i.DatabaseName,
		&i.Username,
		&i.Password,
		&i.Version,
		&i.CreatedAt,
	)
	return &i, err
}

const createMysqlScan = `-- name: CreateMysqlScan :one
INSERT INTO mysql_scans(scan_id, database_id)
    VALUES ($1, $2)
RETURNING
    id, scan_id, database_id
`

type CreateMysqlScanParams struct {
	ScanID     int64 `json:"scan_id"`
	DatabaseID int64 `json:"database_id"`
}

func (q *Queries) CreateMysqlScan(ctx context.Context, arg CreateMysqlScanParams) (*MysqlScan, error) {
	row := q.db.QueryRow(ctx, createMysqlScan, arg.ScanID, arg.DatabaseID)
	var i MysqlScan
	err := row.Scan(&i.ID, &i.ScanID, &i.DatabaseID)
	return &i, err
}

const getMysqlDatabase = `-- name: GetMysqlDatabase :one
SELECT
    mysql_databases.id, mysql_databases.project_id, mysql_databases.host, mysql_databases.port, mysql_databases.database_name, mysql_databases.username, mysql_databases.password, mysql_databases.version, mysql_databases.created_at,
(
        SELECT
            COUNT(*)
        FROM
            Mysql_scans
        WHERE
            Mysql_scans.database_id = mysql_databases.id) AS scan_count
FROM
    mysql_databases
WHERE
    mysql_databases.id = $1
`

type GetMysqlDatabaseRow struct {
	MysqlDatabase MysqlDatabase `json:"mysql_database"`
	ScanCount     int64         `json:"scan_count"`
}

func (q *Queries) GetMysqlDatabase(ctx context.Context, id int64) (*GetMysqlDatabaseRow, error) {
	row := q.db.QueryRow(ctx, getMysqlDatabase, id)
	var i GetMysqlDatabaseRow
	err := row.Scan(
		&i.MysqlDatabase.ID,
		&i.MysqlDatabase.ProjectID,
		&i.MysqlDatabase.Host,
		&i.MysqlDatabase.Port,
		&i.MysqlDatabase.DatabaseName,
		&i.MysqlDatabase.Username,
		&i.MysqlDatabase.Password,
		&i.MysqlDatabase.Version,
		&i.MysqlDatabase.CreatedAt,
		&i.ScanCount,
	)
	return &i, err
}

const getMysqlDatabasesForProject = `-- name: GetMysqlDatabasesForProject :many
SELECT
    id, project_id, host, port, database_name, username, password, version, created_at
FROM
    mysql_databases
WHERE
    project_id = $1
`

func (q *Queries) GetMysqlDatabasesForProject(ctx context.Context, projectID int64) ([]*MysqlDatabase, error) {
	rows, err := q.db.Query(ctx, getMysqlDatabasesForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MysqlDatabase
	for rows.Next() {
		var i MysqlDatabase
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Host,
			&i.Port,
			&i.DatabaseName,
			&i.Username,
			&i.Password,
			&i.Version,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMysqlScan = `-- name: GetMysqlScan :one
SELECT
    id, scan_id, database_id
FROM
    mysql_scans
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) GetMysqlScan(ctx context.Context, id int64) (*MysqlScan, error) {
	row := q.db.QueryRow(ctx, getMysqlScan, id)
	var i MysqlScan
	err := row.Scan(&i.ID, &i.ScanID, &i.DatabaseID)
	return &i, err
}

const getMysqlScanByScanID = `-- name: GetMysqlScanByScanID :one
SELECT
    id, scan_id, database_id
FROM
    mysql_scans
WHERE
    scan_id = $1
LIMIT 1
`

func (q *Queries) GetMysqlScanByScanID(ctx context.Context, scanID int64) (*MysqlScan, error) {
	row := q.db.QueryRow(ctx, getMysqlScanByScanID, scanID)
	var i MysqlScan
	err := row.Scan(&i.ID, &i.ScanID, &i.DatabaseID)
	return &i, err
}

const getProjectInfoForMysqlScanByScanID = `-- name: GetProjectInfoForMysqlScanByScanID :one
SELECT
    projects.id, projects.name, projects.organization_id, projects.remote, projects.created_at,
    mysql_databases.id, mysql_databases.project_id, mysql_databases.host, mysql_databases.port, mysql_databases.database_name, mysql_databases.username, mysql_databases.password, mysql_databases.version, mysql_databases.created_at,
    mysql_scans.id, mysql_scans.scan_id, mysql_scans.database_id
FROM
    projects
    JOIN mysql_databases ON mysql_databases.project_id = projects.id
    JOIN mysql_scans ON mysql_scans.database_id = mysql_databases.id
WHERE
    mysql_scans.scan_id = $1
`

type GetProjectInfoForMysqlScanByScanIDRow struct {
	Project       Project       `json:"project"`
	MysqlDatabase MysqlDatabase `json:"mysql_database"`
	MysqlScan     MysqlScan     `json:"mysql_scan"`
}

func (q *Queries) GetProjectInfoForMysqlScanByScanID(ctx context.Context, scanID int64) (*GetProjectInfoForMysqlScanByScanIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectInfoForMysqlScanByScanID, scanID)
	var i GetProjectInfoForMysqlScanByScanIDRow
	err := row.Scan(
		&i.Project.ID,
		&i.Project.Name,
		&i.Project.OrganizationID,
		&i.Project.Remote,
		&i.Project.CreatedAt,
		&i.MysqlDatabase.ID,
		&i.MysqlDatabase.ProjectID,
		&i.MysqlDatabase.Host,
		&i.MysqlDatabase.Port,
		&i.MysqlDatabase.DatabaseName,
		&i.MysqlDatabase.Username,
		&i.MysqlDatabase.Password,
		&i.MysqlDatabase.Version,
		&i.MysqlDatabase.CreatedAt,
		&i.MysqlScan.ID,
		&i.MysqlScan.ScanID,
		&i.MysqlScan.DatabaseID,
	)
	return &i, err
}

const updateMysqlDatabase = `-- name: UpdateMysqlDatabase :exec
UPDATE
    mysql_databases
SET
    database_name = $2,
    host = $3,
    port = $4,
    username = $5,
    PASSWORD = $6,
    version = $7
WHERE
    id = $1
`

type UpdateMysqlDatabaseParams struct {
	ID           int64          `json:"id"`
	DatabaseName string         `json:"database_name"`
	Host         string         `json:"host"`
	Port         int32          `json:"port"`
	Username     string         `json:"username"`
	Password     string         `json:"password"`
	Version      sql.NullString `json:"version"`
}

func (q *Queries) UpdateMysqlDatabase(ctx context.Context, arg UpdateMysqlDatabaseParams) error {
	_, err := q.db.Exec(ctx, updateMysqlDatabase,
		arg.ID,
		arg.DatabaseName,
		arg.Host,
		arg.Port,
		arg.Username,
		arg.Password,
		arg.Version,
	)
	return err
}

const updateMysqlVersion = `-- name: UpdateMysqlVersion :exec
UPDATE
    mysql_databases
SET
    version = $2
WHERE
    id = $1
`

type UpdateMysqlVersionParams struct {
	ID      int64          `json:"id"`
	Version sql.NullString `json:"version"`
}

func (q *Queries) UpdateMysqlVersion(ctx context.Context, arg UpdateMysqlVersionParams) error {
	_, err := q.db.Exec(ctx, updateMysqlVersion, arg.ID, arg.Version)
	return err
}
