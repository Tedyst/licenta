// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: organization.sql

package queries

import (
	"context"
)

const addOrganizationUser = `-- name: AddOrganizationUser :one
INSERT INTO organization_members(organization_id, user_id, ROLE)
    VALUES ($1, $2, $3)
RETURNING
    id, organization_id, user_id, role, created_at
`

type AddOrganizationUserParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
	Role           int32 `json:"role"`
}

func (q *Queries) AddOrganizationUser(ctx context.Context, arg AddOrganizationUserParams) (*OrganizationMember, error) {
	row := q.db.QueryRow(ctx, addOrganizationUser, arg.OrganizationID, arg.UserID, arg.Role)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return &i, err
}

const getOrganizationByName = `-- name: GetOrganizationByName :one
SELECT
    id, name, created_at
FROM
    organizations
WHERE
    name = $1
LIMIT 1
`

func (q *Queries) GetOrganizationByName(ctx context.Context, name string) (*Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationByName, name)
	var i Organization
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return &i, err
}

const getOrganizationMembers = `-- name: GetOrganizationMembers :many
SELECT
    id, organization_id, user_id, role, created_at
FROM
    organization_members
WHERE
    organization_id = $1
`

func (q *Queries) GetOrganizationMembers(ctx context.Context, organizationID int64) ([]*OrganizationMember, error) {
	rows, err := q.db.Query(ctx, getOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OrganizationMember
	for rows.Next() {
		var i OrganizationMember
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationPermissionsForUser = `-- name: GetOrganizationPermissionsForUser :one
SELECT
    organization_members.role::smallint AS role
FROM
    organization_members
WHERE
    organization_id = $1
    AND user_id = $2
`

type GetOrganizationPermissionsForUserParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
}

func (q *Queries) GetOrganizationPermissionsForUser(ctx context.Context, arg GetOrganizationPermissionsForUserParams) (int16, error) {
	row := q.db.QueryRow(ctx, getOrganizationPermissionsForUser, arg.OrganizationID, arg.UserID)
	var role int16
	err := row.Scan(&role)
	return role, err
}

const getOrganizationUser = `-- name: GetOrganizationUser :one
SELECT
    id, organization_id, user_id, role, created_at
FROM
    organization_members
WHERE
    organization_id = $1
    AND user_id = $2
LIMIT 1
`

type GetOrganizationUserParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
}

func (q *Queries) GetOrganizationUser(ctx context.Context, arg GetOrganizationUserParams) (*OrganizationMember, error) {
	row := q.db.QueryRow(ctx, getOrganizationUser, arg.OrganizationID, arg.UserID)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return &i, err
}

const getOrganizationsByUser = `-- name: GetOrganizationsByUser :many
SELECT
    organizations.id, organizations.name, organizations.created_at,
(
        SELECT
            COUNT(*)
        FROM
            organization_members
        WHERE
            organization_id = organizations.id) AS users,
(
        SELECT
            COUNT(*)
        FROM
            projects
        WHERE
            organization_id = organizations.id) AS projects,
(
        SELECT
            COUNT(*)
        FROM
            scans
            INNER JOIN scan_groups ON scans.scan_group_id = scan_groups.id
            INNER JOIN projects ON scan_groups.project_id = projects.id
        WHERE
            projects.organization_id = organizations.id) AS scans,
(
        SELECT
            COALESCE(MAX(scan_results.severity), 0)::integer
        FROM
            scan_results
            INNER JOIN scans ON scan_results.scan_id = scans.id
            INNER JOIN scan_groups ON scans.scan_group_id = scan_groups.id
            INNER JOIN projects ON scan_groups.project_id = projects.id
        WHERE
            projects.organization_id = organizations.id) AS maximum_severity
FROM
    organizations
    INNER JOIN organization_members ON organizations.id = organization_members.organization_id
WHERE
    organization_members.user_id = $1
`

type GetOrganizationsByUserRow struct {
	Organization    Organization `json:"organization"`
	Users           int64        `json:"users"`
	Projects        int64        `json:"projects"`
	Scans           int64        `json:"scans"`
	MaximumSeverity int32        `json:"maximum_severity"`
}

func (q *Queries) GetOrganizationsByUser(ctx context.Context, userID int64) ([]*GetOrganizationsByUserRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrganizationsByUserRow
	for rows.Next() {
		var i GetOrganizationsByUserRow
		if err := rows.Scan(
			&i.Organization.ID,
			&i.Organization.Name,
			&i.Organization.CreatedAt,
			&i.Users,
			&i.Projects,
			&i.Scans,
			&i.MaximumSeverity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOrganizationUser = `-- name: RemoveOrganizationUser :one
DELETE FROM organization_members
WHERE organization_id = $1
    AND user_id = $2
RETURNING
    id, organization_id, user_id, role, created_at
`

type RemoveOrganizationUserParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
}

func (q *Queries) RemoveOrganizationUser(ctx context.Context, arg RemoveOrganizationUserParams) (*OrganizationMember, error) {
	row := q.db.QueryRow(ctx, removeOrganizationUser, arg.OrganizationID, arg.UserID)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return &i, err
}

const setOrganizationPermissionsForUser = `-- name: SetOrganizationPermissionsForUser :one
UPDATE
    organization_members
SET
    ROLE = $3
WHERE
    organization_id = $1
    AND user_id = $2
RETURNING
    id, organization_id, user_id, role, created_at
`

type SetOrganizationPermissionsForUserParams struct {
	OrganizationID int64 `json:"organization_id"`
	UserID         int64 `json:"user_id"`
	Role           int32 `json:"role"`
}

func (q *Queries) SetOrganizationPermissionsForUser(ctx context.Context, arg SetOrganizationPermissionsForUserParams) (*OrganizationMember, error) {
	row := q.db.QueryRow(ctx, setOrganizationPermissionsForUser, arg.OrganizationID, arg.UserID, arg.Role)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.CreatedAt,
	)
	return &i, err
}
