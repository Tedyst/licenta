// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: scan.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const createScan = `-- name: CreateScan :one
INSERT INTO scans(status, worker_id, scan_group_id, scan_type)
    VALUES ($1, $2, $3, $4)
RETURNING
    id, scan_group_id, scan_type, status, error, worker_id, created_at, ended_at
`

type CreateScanParams struct {
	Status      int32         `json:"status"`
	WorkerID    sql.NullInt64 `json:"worker_id"`
	ScanGroupID int64         `json:"scan_group_id"`
	ScanType    int32         `json:"scan_type"`
}

func (q *Queries) CreateScan(ctx context.Context, arg CreateScanParams) (*Scan, error) {
	row := q.db.QueryRow(ctx, createScan,
		arg.Status,
		arg.WorkerID,
		arg.ScanGroupID,
		arg.ScanType,
	)
	var i Scan
	err := row.Scan(
		&i.ID,
		&i.ScanGroupID,
		&i.ScanType,
		&i.Status,
		&i.Error,
		&i.WorkerID,
		&i.CreatedAt,
		&i.EndedAt,
	)
	return &i, err
}

const createScanBruteforceResult = `-- name: CreateScanBruteforceResult :one
INSERT INTO scan_bruteforce_results(scan_id, scan_type, username, PASSWORD, tried, total)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, scan_id, scan_type, username, password, total, tried, created_at
`

type CreateScanBruteforceResultParams struct {
	ScanID   int64          `json:"scan_id"`
	ScanType int32          `json:"scan_type"`
	Username string         `json:"username"`
	Password sql.NullString `json:"password"`
	Tried    int32          `json:"tried"`
	Total    int32          `json:"total"`
}

func (q *Queries) CreateScanBruteforceResult(ctx context.Context, arg CreateScanBruteforceResultParams) (*ScanBruteforceResult, error) {
	row := q.db.QueryRow(ctx, createScanBruteforceResult,
		arg.ScanID,
		arg.ScanType,
		arg.Username,
		arg.Password,
		arg.Tried,
		arg.Total,
	)
	var i ScanBruteforceResult
	err := row.Scan(
		&i.ID,
		&i.ScanID,
		&i.ScanType,
		&i.Username,
		&i.Password,
		&i.Total,
		&i.Tried,
		&i.CreatedAt,
	)
	return &i, err
}

const createScanGroup = `-- name: CreateScanGroup :one
INSERT INTO scan_groups(project_id, created_by)
    VALUES ($1, $2)
RETURNING
    id, project_id, created_by, created_at
`

type CreateScanGroupParams struct {
	ProjectID int64         `json:"project_id"`
	CreatedBy sql.NullInt64 `json:"created_by"`
}

func (q *Queries) CreateScanGroup(ctx context.Context, arg CreateScanGroupParams) (*ScanGroup, error) {
	row := q.db.QueryRow(ctx, createScanGroup, arg.ProjectID, arg.CreatedBy)
	var i ScanGroup
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const createScanResult = `-- name: CreateScanResult :one
INSERT INTO scan_results(scan_id, severity, message, scan_source)
    VALUES ($1, $2, $3, $4)
RETURNING
    id, scan_id, severity, message, scan_source, created_at
`

type CreateScanResultParams struct {
	ScanID     int64  `json:"scan_id"`
	Severity   int32  `json:"severity"`
	Message    string `json:"message"`
	ScanSource int32  `json:"scan_source"`
}

func (q *Queries) CreateScanResult(ctx context.Context, arg CreateScanResultParams) (*ScanResult, error) {
	row := q.db.QueryRow(ctx, createScanResult,
		arg.ScanID,
		arg.Severity,
		arg.Message,
		arg.ScanSource,
	)
	var i ScanResult
	err := row.Scan(
		&i.ID,
		&i.ScanID,
		&i.Severity,
		&i.Message,
		&i.ScanSource,
		&i.CreatedAt,
	)
	return &i, err
}

const getCountOfScanGroupsForProject = `-- name: GetCountOfScanGroupsForProject :one
SELECT
    COUNT(*)
FROM
    scan_groups
WHERE
    project_id = $1
`

func (q *Queries) GetCountOfScanGroupsForProject(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getCountOfScanGroupsForProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getScan = `-- name: GetScan :one
SELECT
    scans.id, scans.scan_group_id, scans.scan_type, scans.status, scans.error, scans.worker_id, scans.created_at, scans.ended_at,
(
        SELECT
            COALESCE(MAX(scan_results.severity), 0)::integer
        FROM
            scan_results
        WHERE
            scan_id = scans.id) AS maximum_severity
FROM
    scans
WHERE
    scans.id = $1
`

type GetScanRow struct {
	Scan            Scan  `json:"scan"`
	MaximumSeverity int32 `json:"maximum_severity"`
}

func (q *Queries) GetScan(ctx context.Context, id int64) (*GetScanRow, error) {
	row := q.db.QueryRow(ctx, getScan, id)
	var i GetScanRow
	err := row.Scan(
		&i.Scan.ID,
		&i.Scan.ScanGroupID,
		&i.Scan.ScanType,
		&i.Scan.Status,
		&i.Scan.Error,
		&i.Scan.WorkerID,
		&i.Scan.CreatedAt,
		&i.Scan.EndedAt,
		&i.MaximumSeverity,
	)
	return &i, err
}

const getScanBruteforceResults = `-- name: GetScanBruteforceResults :many
SELECT
    id, scan_id, scan_type, username, password, total, tried, created_at
FROM
    scan_bruteforce_results
WHERE
    scan_id = $1
`

func (q *Queries) GetScanBruteforceResults(ctx context.Context, scanID int64) ([]*ScanBruteforceResult, error) {
	rows, err := q.db.Query(ctx, getScanBruteforceResults, scanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ScanBruteforceResult
	for rows.Next() {
		var i ScanBruteforceResult
		if err := rows.Scan(
			&i.ID,
			&i.ScanID,
			&i.ScanType,
			&i.Username,
			&i.Password,
			&i.Total,
			&i.Tried,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScanGroup = `-- name: GetScanGroup :one
SELECT
    id, project_id, created_by, created_at
FROM
    scan_groups
WHERE
    id = $1
`

func (q *Queries) GetScanGroup(ctx context.Context, id int64) (*ScanGroup, error) {
	row := q.db.QueryRow(ctx, getScanGroup, id)
	var i ScanGroup
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return &i, err
}

const getScanGroupsForProject = `-- name: GetScanGroupsForProject :many
SELECT
    scan_groups.id, scan_groups.project_id, scan_groups.created_by, scan_groups.created_at,
    scans.id, scans.scan_group_id, scans.scan_type, scans.status, scans.error, scans.worker_id, scans.created_at, scans.ended_at,
(
        SELECT
            COALESCE(MAX(scan_results.severity), 0)::integer
        FROM
            scan_results
        WHERE
            scan_id = scans.id) AS maximum_severity
FROM
    scan_groups
    INNER JOIN scans ON scan_groups.id = scans.scan_group_id
WHERE
    project_id = $1
`

type GetScanGroupsForProjectRow struct {
	ScanGroup       ScanGroup `json:"scan_group"`
	Scan            Scan      `json:"scan"`
	MaximumSeverity int32     `json:"maximum_severity"`
}

func (q *Queries) GetScanGroupsForProject(ctx context.Context, projectID int64) ([]*GetScanGroupsForProjectRow, error) {
	rows, err := q.db.Query(ctx, getScanGroupsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetScanGroupsForProjectRow
	for rows.Next() {
		var i GetScanGroupsForProjectRow
		if err := rows.Scan(
			&i.ScanGroup.ID,
			&i.ScanGroup.ProjectID,
			&i.ScanGroup.CreatedBy,
			&i.ScanGroup.CreatedAt,
			&i.Scan.ID,
			&i.Scan.ScanGroupID,
			&i.Scan.ScanType,
			&i.Scan.Status,
			&i.Scan.Error,
			&i.Scan.WorkerID,
			&i.Scan.CreatedAt,
			&i.Scan.EndedAt,
			&i.MaximumSeverity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScanResults = `-- name: GetScanResults :many
SELECT
    id, scan_id, severity, message, scan_source, created_at
FROM
    scan_results
WHERE
    scan_id = $1
`

func (q *Queries) GetScanResults(ctx context.Context, scanID int64) ([]*ScanResult, error) {
	rows, err := q.db.Query(ctx, getScanResults, scanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ScanResult
	for rows.Next() {
		var i ScanResult
		if err := rows.Scan(
			&i.ID,
			&i.ScanID,
			&i.Severity,
			&i.Message,
			&i.ScanSource,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScanResultsByScanIdAndScanSource = `-- name: GetScanResultsByScanIdAndScanSource :many
SELECT
    id, scan_id, severity, message, scan_source, created_at
FROM
    scan_results
WHERE
    scan_id = $1
    AND scan_source = $2
`

type GetScanResultsByScanIdAndScanSourceParams struct {
	ScanID     int64 `json:"scan_id"`
	ScanSource int32 `json:"scan_source"`
}

func (q *Queries) GetScanResultsByScanIdAndScanSource(ctx context.Context, arg GetScanResultsByScanIdAndScanSourceParams) ([]*ScanResult, error) {
	rows, err := q.db.Query(ctx, getScanResultsByScanIdAndScanSource, arg.ScanID, arg.ScanSource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ScanResult
	for rows.Next() {
		var i ScanResult
		if err := rows.Scan(
			&i.ID,
			&i.ScanID,
			&i.Severity,
			&i.Message,
			&i.ScanSource,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScansForProject = `-- name: GetScansForProject :many
SELECT
    scans.id, scans.scan_group_id, scans.scan_type, scans.status, scans.error, scans.worker_id, scans.created_at, scans.ended_at,
(
        SELECT
            MAX(scan_results.severity)::integer
        FROM
            scan_results
        WHERE
            scan_id = scans.id) AS maximum_severity,
(
        SELECT
            id
        FROM
            postgres_scans
        WHERE
            postgres_scans.scan_id = scans.id
        LIMIT 1) AS postgres_scan
FROM
    scans
    INNER JOIN scan_groups ON scans.scan_group_id = scan_groups.id
WHERE
    scan_groups.project_id = $1
ORDER BY
    scans.id DESC
`

type GetScansForProjectRow struct {
	Scan            Scan  `json:"scan"`
	MaximumSeverity int32 `json:"maximum_severity"`
	PostgresScan    int64 `json:"postgres_scan"`
}

func (q *Queries) GetScansForProject(ctx context.Context, projectID int64) ([]*GetScansForProjectRow, error) {
	rows, err := q.db.Query(ctx, getScansForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetScansForProjectRow
	for rows.Next() {
		var i GetScansForProjectRow
		if err := rows.Scan(
			&i.Scan.ID,
			&i.Scan.ScanGroupID,
			&i.Scan.ScanType,
			&i.Scan.Status,
			&i.Scan.Error,
			&i.Scan.WorkerID,
			&i.Scan.CreatedAt,
			&i.Scan.EndedAt,
			&i.MaximumSeverity,
			&i.PostgresScan,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScansForScanGroup = `-- name: GetScansForScanGroup :many
SELECT
    id, scan_group_id, scan_type, status, error, worker_id, created_at, ended_at
FROM
    scans
WHERE
    scan_group_id = $1
`

func (q *Queries) GetScansForScanGroup(ctx context.Context, scanGroupID int64) ([]*Scan, error) {
	rows, err := q.db.Query(ctx, getScansForScanGroup, scanGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Scan
	for rows.Next() {
		var i Scan
		if err := rows.Scan(
			&i.ID,
			&i.ScanGroupID,
			&i.ScanType,
			&i.Status,
			&i.Error,
			&i.WorkerID,
			&i.CreatedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScanBruteforceResult = `-- name: UpdateScanBruteforceResult :exec
UPDATE
    scan_bruteforce_results
SET
    PASSWORD = $2,
    tried = $3,
    total = $4
WHERE
    id = $1
`

type UpdateScanBruteforceResultParams struct {
	ID       int64          `json:"id"`
	Password sql.NullString `json:"password"`
	Tried    int32          `json:"tried"`
	Total    int32          `json:"total"`
}

func (q *Queries) UpdateScanBruteforceResult(ctx context.Context, arg UpdateScanBruteforceResultParams) error {
	_, err := q.db.Exec(ctx, updateScanBruteforceResult,
		arg.ID,
		arg.Password,
		arg.Tried,
		arg.Total,
	)
	return err
}

const updateScanStatus = `-- name: UpdateScanStatus :exec
UPDATE
    scans
SET
    status = $2,
    error = $3,
    ended_at = $4
WHERE
    id = $1
`

type UpdateScanStatusParams struct {
	ID      int64              `json:"id"`
	Status  int32              `json:"status"`
	Error   sql.NullString     `json:"error"`
	EndedAt pgtype.Timestamptz `json:"ended_at"`
}

func (q *Queries) UpdateScanStatus(ctx context.Context, arg UpdateScanStatusParams) error {
	_, err := q.db.Exec(ctx, updateScanStatus,
		arg.ID,
		arg.Status,
		arg.Error,
		arg.EndedAt,
	)
	return err
}
