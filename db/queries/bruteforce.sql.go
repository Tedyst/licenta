// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: bruteforce.sql

package queries

import (
	"context"
	"database/sql"
)

const createBruteforcedPassword = `-- name: CreateBruteforcedPassword :one
INSERT INTO bruteforced_passwords(hash, username, PASSWORD, last_bruteforce_id, project_id)
    VALUES ($1, $2, $3, $4, $5)
RETURNING
    id, hash, username, password, last_bruteforce_id, project_id
`

type CreateBruteforcedPasswordParams struct {
	Hash             string         `json:"hash"`
	Username         string         `json:"username"`
	Password         sql.NullString `json:"password"`
	LastBruteforceID sql.NullInt64  `json:"last_bruteforce_id"`
	ProjectID        sql.NullInt64  `json:"project_id"`
}

func (q *Queries) CreateBruteforcedPassword(ctx context.Context, arg CreateBruteforcedPasswordParams) (*BruteforcedPassword, error) {
	row := q.db.QueryRow(ctx, createBruteforcedPassword,
		arg.Hash,
		arg.Username,
		arg.Password,
		arg.LastBruteforceID,
		arg.ProjectID,
	)
	var i BruteforcedPassword
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Username,
		&i.Password,
		&i.LastBruteforceID,
		&i.ProjectID,
	)
	return &i, err
}

const getBruteforcePasswordsForProjectCount = `-- name: GetBruteforcePasswordsForProjectCount :one
SELECT
    SUM(count)
FROM (
    SELECT
        COUNT(*)
    FROM
        default_bruteforce_passwords
    UNION ALL
    SELECT
        COUNT(*)
    FROM
        docker_results
        INNER JOIN docker_layers ON docker_results.layer_id = docker_layers.id
        INNER JOIN docker_images ON docker_layers.image_id = docker_images.id
    WHERE
        docker_images.project_id = $1
    UNION ALL
    SELECT
        COUNT(*)
    FROM
        git_results
        INNER JOIN git_commits ON git_results.commit = git_commits.id
        INNER JOIN git_repositories ON git_commits.repository_id = git_repositories.id
    WHERE
        git_repositories.project_id = $1) AS count
`

func (q *Queries) GetBruteforcePasswordsForProjectCount(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getBruteforcePasswordsForProjectCount, projectID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getBruteforcePasswordsPaginated = `-- name: GetBruteforcePasswordsPaginated :many
(
    SELECT
        default_bruteforce_passwords.id,
        PASSWORD
    FROM
        default_bruteforce_passwords
    WHERE
        default_bruteforce_passwords.id > $1
    LIMIT $2)
UNION (
    SELECT
        -1,
        docker_results.PASSWORD
    FROM
        docker_results
        INNER JOIN docker_layers ON docker_results.layer_id = docker_layers.id
        INNER JOIN docker_images ON docker_layers.image_id = docker_images.id
    WHERE
        docker_images.project_id = $3
        AND docker_results.PASSWORD IS NOT NULL
        AND $1 = - 1)
UNION (
    SELECT
        -1,
        git_results.PASSWORD
    FROM
        git_results
        INNER JOIN git_commits ON git_results.commit = git_commits.id
        INNER JOIN git_repositories ON git_commits.repository_id = git_repositories.id
    WHERE
        git_repositories.project_id = $3
        AND git_results.PASSWORD IS NOT NULL
        AND $1 = - 1)
`

type GetBruteforcePasswordsPaginatedParams struct {
	LastID    int64 `json:"last_id"`
	Limit     int32 `json:"limit"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) GetBruteforcePasswordsPaginated(ctx context.Context, arg GetBruteforcePasswordsPaginatedParams) ([]*DefaultBruteforcePassword, error) {
	rows, err := q.db.Query(ctx, getBruteforcePasswordsPaginated, arg.LastID, arg.Limit, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DefaultBruteforcePassword
	for rows.Next() {
		var i DefaultBruteforcePassword
		if err := rows.Scan(&i.ID, &i.Password); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBruteforcePasswordsSpecificForProject = `-- name: GetBruteforcePasswordsSpecificForProject :many
SELECT
    docker_results.PASSWORD
FROM
    docker_results
    INNER JOIN docker_layers ON docker_results.layer_id = docker_layers.id
    INNER JOIN docker_images ON docker_layers.image_id = docker_images.id
WHERE
    docker_images.project_id = $1
UNION ALL
SELECT
    git_results.PASSWORD
FROM
    git_results
    INNER JOIN git_commits ON git_results.commit = git_commits.id
    INNER JOIN git_repositories ON git_commits.repository_id = git_repositories.id
WHERE
    git_repositories.project_id = $1
`

func (q *Queries) GetBruteforcePasswordsSpecificForProject(ctx context.Context, projectID int64) ([]sql.NullString, error) {
	rows, err := q.db.Query(ctx, getBruteforcePasswordsSpecificForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var password sql.NullString
		if err := rows.Scan(&password); err != nil {
			return nil, err
		}
		items = append(items, password)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBruteforcedPasswords = `-- name: GetBruteforcedPasswords :one
SELECT
    id, hash, username, password, last_bruteforce_id, project_id
FROM
    bruteforced_passwords
WHERE
    hash = $1
    AND username = $2
    AND (project_id = $3
        OR project_id = NULL)
LIMIT 1
`

type GetBruteforcedPasswordsParams struct {
	Hash      string        `json:"hash"`
	Username  string        `json:"username"`
	ProjectID sql.NullInt64 `json:"project_id"`
}

func (q *Queries) GetBruteforcedPasswords(ctx context.Context, arg GetBruteforcedPasswordsParams) (*BruteforcedPassword, error) {
	row := q.db.QueryRow(ctx, getBruteforcedPasswords, arg.Hash, arg.Username, arg.ProjectID)
	var i BruteforcedPassword
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Username,
		&i.Password,
		&i.LastBruteforceID,
		&i.ProjectID,
	)
	return &i, err
}

const getSpecificBruteforcePasswordID = `-- name: GetSpecificBruteforcePasswordID :one
SELECT
    subq.id
FROM (
    SELECT
        id
    FROM
        default_bruteforce_passwords
    WHERE
        default_bruteforce_passwords.PASSWORD = $1
    UNION ALL
    SELECT
        -1
    FROM
        docker_results
        INNER JOIN docker_layers ON docker_results.layer_id = docker_layers.id
        INNER JOIN docker_images ON docker_layers.image_id = docker_images.id
    WHERE
        docker_images.project_id = $2
        AND docker_results.PASSWORD = $1
    UNION ALL
    SELECT
        -1
    FROM
        git_results
        INNER JOIN git_commits ON git_results.commit = git_commits.id
        INNER JOIN git_repositories ON git_commits.repository_id = git_repositories.id
    WHERE
        git_repositories.project_id = $2
        AND git_results.PASSWORD = $1) AS subq
LIMIT 1
`

type GetSpecificBruteforcePasswordIDParams struct {
	Password  string `json:"password"`
	ProjectID int64  `json:"project_id"`
}

func (q *Queries) GetSpecificBruteforcePasswordID(ctx context.Context, arg GetSpecificBruteforcePasswordIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSpecificBruteforcePasswordID, arg.Password, arg.ProjectID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertBruteforcePasswords = `-- name: InsertBruteforcePasswords :exec
INSERT INTO default_bruteforce_passwords(PASSWORD)
    VALUES (unnest($1::text[]))
ON CONFLICT
    DO NOTHING
`

func (q *Queries) InsertBruteforcePasswords(ctx context.Context, passwords []string) error {
	_, err := q.db.Exec(ctx, insertBruteforcePasswords, passwords)
	return err
}

const updateBruteforcedPassword = `-- name: UpdateBruteforcedPassword :one
UPDATE
    bruteforced_passwords
SET
    last_bruteforce_id = $2,
    PASSWORD = $3
WHERE
    id = $1
RETURNING
    id, hash, username, password, last_bruteforce_id, project_id
`

type UpdateBruteforcedPasswordParams struct {
	ID               int64          `json:"id"`
	LastBruteforceID sql.NullInt64  `json:"last_bruteforce_id"`
	Password         sql.NullString `json:"password"`
}

func (q *Queries) UpdateBruteforcedPassword(ctx context.Context, arg UpdateBruteforcedPasswordParams) (*BruteforcedPassword, error) {
	row := q.db.QueryRow(ctx, updateBruteforcedPassword, arg.ID, arg.LastBruteforceID, arg.Password)
	var i BruteforcedPassword
	err := row.Scan(
		&i.ID,
		&i.Hash,
		&i.Username,
		&i.Password,
		&i.LastBruteforceID,
		&i.ProjectID,
	)
	return &i, err
}
